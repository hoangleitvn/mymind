---
type: linkedin-engagement
created: '2025-12-10'
last_updated: '2025-12-10'

author:
  name: "Dr Milan Milanović"
  profile: "people/milan-milanovic.md"

post:
  source: "external"
  url: "https://www.linkedin.com/posts/milanmilanovic"
  date: '2025-12-10'
  reactions: 86
  comments_count: 10
  reposts: 0
  theme: "software-architecture"
  angle: "tool-categorization"
  key_points:
    - Comprehensive list of architecture diagramming tools
    - Categorized by type: Modeling, Code-based, Automated, Diagramming
    - Includes both free and paid options
    - Links to full list resource
  hashtags: []

notable_comments:
  - author: "Bob B."
    content: "For diagrams-as-code, I've found that the real challenge isn't the tool itself, but integrating the diagram generation into the CI/CD pipeline so it stays current with the codebase."
    reactions: 1
    insight: "CI/CD integration for keeping diagrams current"
  - author: "Mohammad Javad Farahani"
    content: "Choosing the right tool often depends on lifecycle: early-stage teams benefit from visual tools like IcePanel or Excalidraw, while mature systems get the most value from Structurizr or diagrams-as-code."
    reactions: 1
    insight: "Tool choice depends on team/system maturity"

our_engagement:
  - id: 1
    type: "comment"
    reply_to: null
    status: "draft"
    timestamp: '2025-12-10'
    content: |
Great list. We use both: drawing tools (Draw.io, Miro, Lucidchart) for quick whiteboarding, and diagrams-as-code (C4 with Structurizr, PlantUML, Mermaid, Python Diagrams) for documentation that lives with the code.

I'm a fan of diagrams-as-code. Now exploring how to integrate into CI/CD pipelines and auto-generate diagrams from code with consistent branding.

Curious: how do you enforce diagramming standards or branding across teams?
    strategy: "Personal Experience + Thoughtful Question - shares real tool usage, then asks genuine question about standardization"

engagement_status: "draft"
---

## Analysis

**Post Type:** List/resource post
**Engagement:** High (86 reactions in 1 hour, 10 comments)
**Timing:** Fresh post (1 hour old), good engagement window

**Value-add approach:** Rather than just stating tool preference, shared:
1. Real migration experience (Visio → Mermaid)
2. Key insight: proximity to code matters more than tool features
3. Practical pattern: visual for early stage, code-based for stable

**Why this comment works:**
- Adds genuine experience, not just "great list"
- Builds on Bob B.'s CI/CD comment about keeping diagrams current
- Offers actionable pattern (visual → code-based progression)
- Aligns with my positioning: foundation-first, practical engineering
